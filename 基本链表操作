#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
typedef struct Node* List;
typedef struct Node{
    int value;
    List Next;
}Node;
//初始化不需要任何参数，返回指针，在主函数里用另一个指针指向就好了，这次初始化用的是尾插法，回头可以改下头插法，因为两种方法可以实现正序和逆序
List MakeEmptyAndInitial(){
    /*下面的判断语句是对头结点申请并初妈化*/
    List L;//定义头结点
    L=(List)malloc(sizeof(Node));//malloc前面括号就是头结点L的类型，sizeof括号是指向的数据类型
    if(L == NULL)//记得永远不能用单个等号，那个是赋值号
        printf("内存空间不足");
    else
        L->Next = NULL;

    int value;
    List r=L;//申请头结点位置，尾插法，用来移动做其他操作
     /*下面语句是读入数值并按*/
    while(scanf("%d ",&value)!= EOF)// 输入结束按ctrl+z结束输入,记得要把scan 整个部分不等于EOF
    {
            List p=(List)malloc(sizeof(Node));
            p->value=value;

            r->Next=p;//这里是用空头结点的指针指向P， 不能直接用r,就变成r指向了P，没有和之前L头结点联系起来，如果直接用L也行，但后面继续连接其他新结点就很麻烦，不断用L.Next.Next,还不能直接移动L
            r=p;//这里的P什么时候释放好？测试时候如果直接在下面一释放，就发现结果错误了
    }
    r->Next=NULL;//此时r在最后一个结点，设置其指针Next为0值。
    return L;
}
int length(List L)
{
    List tem=L->Next;
    int len=0;
    while(tem)
    {
        len++;
        tem=tem->Next;
    }
    return len;
}

int FindKth(int K, List L)
{   int value;
    List tem=L->Next;
    for(int i=0;i<K;i++)
    {
        value=tem->value;
        tem=tem->Next;
    }
    return value;
}

int FindX(int X,List L)
{
    int K=1;
    List tem=L->Next;
    while((tem->value!=X)&&(tem!=NULL))
    {
        tem=tem->Next;
        K++;
    }
    if(tem==NULL)
        K=0;

    return K;
}
void Insert(int X,int i,List L)
{
    List tem=L->Next;
    for(int j=0;j<i-1;j++)
        tem=tem->Next;

    List p=(List)malloc(sizeof(Node));
    p->value=X;
    p->Next=tem->Next;//这里为什么是这样子替换，当直接用 tem 没起到插入作用，但前面已经定义 tem从指向第一个结点开始 了
    tem->Next=p;
}
int main(){
    List L1=MakeEmptyAndInitial();
    Insert(13,5,L1);
    List tem1=L1->Next;
    while(tem1){
        printf("%d ",tem1->value);
        tem1=tem1->Next;
    }

    int a=FindKth(5, L1);
    int b=FindX(5, L1);
    printf("%d %d ",a,b);

    return 0;
}

